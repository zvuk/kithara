# Kanban — `kithara-io`

Этот документ содержит задачи, относящиеся **только** к сабкрейту `crates/kithara-io`.

Общие инструкции (обязательная преамбула к каждой задаче): см. `kithara/docs/kanban-instructions.md`.

---

## Цель

`kithara-io` — bridge-слой между async источниками байт (сеть/HLS/file) и sync потребителями (`Read + Seek`) в decode thread.

Здесь живёт:
- bounded буферизация (по байтам),
- backpressure,
- корректная EOF семантика,
- понятный, тестируемый контракт `Seek` (best-effort или явно “unsupported”).

---

## Инварианты (обязательные)

- **EOF критично:** `Read::read() -> Ok(0)` означает истинный End-Of-Stream. Нельзя возвращать `Ok(0)` пока поток реально не завершён.
- **Backpressure обязательна:** если consumer не читает — producer должен блокироваться/дросселироваться; память не должна расти без ограничений.
- **Ошибки типизированы:** различать recoverable vs fatal на уровне контракта (по крайней мере “можно продолжать” vs “сессия завершена”).
- **Детерминированные тесты:** без внешней сети, без флейковых `sleep`, без зависаний.
- Bridge не должен скрывать “плохие” состояния:
  - seek вне поддерживаемого диапазона должен возвращать явную ошибку,
  - после fatal ошибки — потребитель должен получить ошибку и затем корректно завершиться.

См. детали и причины в `kithara/docs/constraints.md`.

---

## Компоненты и потоки (контракт) — ориентир

Ожидаемая структура (может отличаться по именам, но ответственность должна быть ясной):

- `bridge`: высокоуровневая сборка writer/reader половинок.
- `writer`: принимает чанки байт от async producer’а и пишет в bounded буфер.
- `reader`: реализует `Read` (и возможно `Seek`) поверх bounded буфера.
- `errors`: типизированные ошибки и “конечные состояния” потока (EOS vs fatal).
- (опционально) `metrics`: только если уже есть стандартный механизм телеметрии в workspace; не тянуть новые зависимости ради метрик.
