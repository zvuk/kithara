# Kithara — Kanban: общие инструкции (prelude для всех бордов)

Этот документ содержит общие инструкции, которые применяются **ко всем** задачам во всех `docs/kanban-*.md`.

## 0) Что читать перед началом любой задачи

Перед началом любой задачи агент обязан прочитать:

1) `kithara/AGENTS.md` — правила разработки (границы изменений, TDD, зависимости, стиль).
2) `kithara/docs/constraints.md` — ограничения и “грабли” проекта (EOF, backpressure, offline и т.д.).
3) Релевантный борд: `kithara/docs/kanban-<crate>.md`.

Если в борде есть “контракт” для публичного API — он является целью реализации.

## 1) Как выполнять задачи (TDD-first)

**Правило:** каждая задача выполняется через тесты.

Рекомендуемый цикл:
1) Добавить тест(ы), которые фиксируют желаемое поведение.
2) Запустить тесты и убедиться, что новый тест падает по ожидаемой причине.
3) Реализовать минимальный код, чтобы тест прошёл.
4) Рефакторить только после прохождения тестов.

Тесты:
- детерминированные,
- без внешней сети,
- без бесконечных циклов/ожиданий,
- фиксируют контракт, а не случайные детали реализации.

## 2) Границы изменений: “одно изменение — один крейт”

По умолчанию агент работает **внутри одного** сабкрейта `crates/<name>`.

Нельзя “заодно” править соседние крейты.

Разрешённые узкие исключения описаны в `kithara/AGENTS.md` (workspace-first deps, workspace-wide configs, docs).

## 3) Зависимости (workspace-first + no duplicates)

### 3.1 Workspace-first
- Все версии зависимостей объявляются в `kithara/Cargo.toml` в `[workspace.dependencies]`.
- Внутри сабкрейтов подключение только через `{ workspace = true }` (включая dev/build).

### 3.2 Не добавлять дубликаты
Перед тем как добавлять новую библиотеку:
- проверить, нет ли уже подходящего решения в stdlib или в `[workspace.dependencies]`;
- если функционал уже покрыт — **не добавлять** новую зависимость.

Пример: для логирования используем `tracing`; не добавляем `log`, если он нужен только “потому что привычнее”.

Если новой зависимости избежать нельзя:
- кратко обосновать необходимость в описании задачи/PR (1–2 предложения).

## 4) Стиль кода: короткие имена и импорты

- Избегать “трёхэтажных” путей `some_lib::some_mod::some_func` в теле кода.
- **Все `use`-импорты — в начале файла.** Не размещать `use` внутри функций/методов/блоков.
- Полные пути допустимы только когда это явно улучшает читаемость (обычно: конфликт имён или единичное использование).

## 5) Форматирование и проверки

После каждого логически завершённого чекбокса (или серии правок в рамках одного чекбокса):
1) `cargo fmt` (workspace или целевой крейт).
2) `cargo test` (минимум целевой крейт/нужный набор тестов).

Цель: минимизировать шум диффов и ловить проблемы рано.

## 6) Минимальные “player-grade” инварианты (напоминание)

Если задача затрагивает bridge/streaming/декодирование, обязательно держать в голове:

- `Read::read() -> Ok(0)` означает **EOF** для потребителей. Нельзя возвращать `Ok(0)` пока поток реально не завершён.
- Backpressure обязательна: память не должна расти без ограничений.
- Ошибки различаются на recoverable vs fatal; контракт распространения ошибок должен быть явным и тестируемым.
- Offline/кэш: cache hits не “улучшают” ABR throughput; processed keys должны кэшироваться после `key_processor_cb`.

Подробности — в `docs/constraints.md` и в бордах по крейтам.

## 7) Как отмечать выполнение чекбоксов

В `docs/kanban-<crate>.md`:
- выполненные пункты отмечаются как `[x]`,
- невыполненные — `[ ]`.

**Не добавлять** дополнительные статусы (in progress / review и т.д.) — это живёт в вашей системе канбана вне репозитория.