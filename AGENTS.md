# Kithara — правила кодирования для автономных агентов

## 0.f) Запрет “на будущее” (no speculative code / no future-proofing)
**Правило (нормативно):** агент **не должен** добавлять код “на будущее”, который не используется в рамках текущей задачи/чекбокса и не зафиксирован публичным контрактом.

Запрещено:
- добавлять неиспользуемые helper-функции/методы/поля “вдруг пригодится”;
- добавлять “интроспекцию”, “debug helpers”, “возможные расширения”, если они не используются прямо сейчас;
- оставлять “удобные” методы без тестов/использования;
- добавлять альтернативные ветки/варианты поведения без явного требования задачи.

## 0.d) Зависимости: не тащить дубликаты (dependency hygiene)
**Правило:** агент **не должен** добавлять новую зависимость, если нужный функционал уже есть в workspace или в стандартной библиотеке.

Перед добавлением любого нового crate:
1) проверить `kithara/Cargo.toml` (`[workspace.dependencies]`) — нет ли уже подходящей библиотеки;
2) предпочесть уже существующую (например, для логирования используем `tracing`, не добавляем `log`);
3) если аналог уже есть — **новую зависимость не добавлять**.

Если новой зависимости избежать нельзя:
- обосновать необходимость в описании задачи/PR (1–2 предложения, что именно не покрывается текущими зависимостями);
- добавить её **сначала** в `[workspace.dependencies]`, затем подключить в целевом крейте как `{ workspace = true }`.

## 0) Главные принципы

- Минимум магии и скрытых зависимостей.
- Предсказуемость, тестируемость, воспроизводимость.
- Компоненты должны быть слабо связаны и заменяемы.
- Код — источник истины. Длинные объяснения — в `README` соответствующего сабкрейта.

## 1) Управление зависимостями (workspace-first)

**Правило:** все зависимости добавляются сначала в workspace, затем подключаются в конкретном крейте.

### 1.1 Где объявлять версии
- Версии зависимостей объявляются в корневом `Cargo.toml` workspace в секции:
  - `[workspace.dependencies]`
- Это относится ко всем зависимостям:
  - обычным (`dependencies`)
  - dev (`dev-dependencies`)
  - build (`build-dependencies`)

### 1.2 Как подключать в крейтах
- В `Cargo.toml` конкретного крейта зависимости подключаются без версии:
  - `dep = { workspace = true }`
- Никаких версий в сабкрейтах. Если нужно изменить версию — меняем только в `[workspace.dependencies]`.

### 1.3 Запреты
- Не добавлять “временные” зависимости без реальной необходимости.
- Не тянуть тяжёлые зависимости ради мелкой утилиты (сначала оцени стоимость).
- Не дублировать одну и ту же зависимость с разными фичами в разных крейтах без явной причины.

---

## 2) Стиль кода (коротко и стабильно)

### 2.0 Импорты и короткие имена (no deep namespaces)
**Правило:** избегать “трёхэтажных” путей вида `some_lib::some_mod::some_func` в коде.

- Все `use`-импорты должны быть **в начале файла** (включая `use some_lib::some_mod;`) — **не размещать `use` внутри функций/методов/блоков**.
- Предпочитать импорты в начале файла и короткие, читаемые имена в теле.
- Допускаются полные пути только когда это **явно улучшает** читаемость (например, разрешение конфликтов имён или единичное использование).

### 2.1 Имена
- Выбирать как можно более простые и короткие имена для функций/методов/типов.
- Предпочитать стандартные, очевидные слова (`open`, `new`, `get`, `put`, `read`, `write`, `seek`, `stream`, `send`, `recv`), если они точно отражают смысл.
- Избегать “умных”/длинных имён, которые кодируют внутреннюю реализацию или историю рефакторингов.

### 2.2 Комментарии и документация
**Цель:** минимизировать устаревающие комментарии и держать объяснения рядом с интерфейсами.

- Комментарии в коде — только короткие, однострочные.
- Не добавлять “простыни” комментариев в начале файлов.
- Не писать комментарии, которые повторяют код (очевидное).
- Всё, что требует объяснения (контракты, инварианты, жизненный цикл, протоколы, схемы кэша), описывается в `README.md` соответствующего сабкрейта.

### 2.3 Размер файлов и декомпозиция
**Цель:** Rust файлы должны оставаться небольшими, чтобы упрощать навигацию и снижать стоимость ревью.

- Не раздувать один `.rs` файл “до бесконечности”.
- Если файл начинает превращаться в “свалку абстракций”, выносить:
  - типы в отдельные файлы,
  - имплементации в `mod.rs` + `*.rs`,
  - политики/стратегии в отдельные модули.
- Эвристики (что выносить):
  - большие `enum`/`struct` + их `impl` блоки,
  - подсистемы (например: `lru_index`, `fs_layout`, `atomic_write`, `url_canon`, `key_processor`).

### Тесты и фикстуры: `src/` только для прод-кода
**Правило:** `src/` должен содержать только код, который мы тестируем (prod-код). Тестовая инфраструктура не должна “просачиваться” в `src/`.

- Если тест требует **существенных фикстур** (локальный сервер, большие плейлисты/сегменты, генераторы контента, счётчики запросов, сложные сценарии) — это **integration tests**:
  - размещать в `crates/<crate>/tests/` (например `tests/fixture.rs`, `tests/integration_*.rs`);
  - фикстуры можно выносить в `crates/<crate>/tests/fixture/` (подмодули), если их много.
- В `src/` допускаются только:
  - небольшие unit-тесты рядом с кодом,
  - очень маленькие test helpers под `#[cfg(test)]`, которые не превращают `src/` в “склад фикстур”.
- Запрещено добавлять “большие” фикстуры/серверы в `src/` даже под `#[cfg(test)]`.
- Критерий “существенные фикстуры”: если это не помещается “компактно” в один unit-тест или требует отдельной структуры/протокола — значит это `tests/`.


---

## 3) Разработка через TDD

**Правило:** изменения делаются через тесты, описывающие желаемое поведение.

### 4.1 Порядок работы
1) Сформулировать поведение через тест(ы) (integration/unit — по месту).
2) Запустить тесты и убедиться, что новый тест падает по ожидаемой причине.
3) Реализовать минимальный код, чтобы тест прошёл.
4) Рефакторить только после прохождения тестов.

### 4.2 Требования к тестам
- Тесты должны быть детерминированными.
- Тесты не должны зависеть от внешней сети.
- Тесты должны быть “умеренными” по объёму логов и данных (без чтения гигабайт и без шумных дампов).
- Тесты фиксируют контракт, а не текущие случайные детали реализации.

---

## 4) Обобщённое программирование (generics-first)

**Правило:** расширяемость достигается через дженерики и абстракции, а не через копипасту и жёсткие связи.

### 4.1 Предпочитать стандартные и tokio-абстракции
**Цель:** меньше “велосипедов”, больше совместимости с экосистемой.
- По возможности использовать стандартные и `tokio` трейты/типы и их идиомы:
  - конвертации (`From`, `TryFrom`, `Into`, `AsRef`),
  - ошибки (`std::error::Error`, `thiserror`),
  - итераторы и адаптеры (`Iterator`, `IntoIterator`),
  - I/O трейты (`Read`, `Seek`, `Write`, `AsyncRead`, `AsyncWrite` там, где уместно),
  - каналы/синхронизация `tokio` (если компонент уже на tokio) вместо кастомных решений.
- Если стандартный трейт подходит, не вводить новый “почти такой же” трейт.

### 4.2 Использование generics
- Базовые структуры делаем обобщёнными по:
  - типу события,
  - типу источника/транспорта,
  - типу кэша/хранилища,
  - политике (ABR/eviction) и т.п.
- Расширение поведения — через параметры типов, трейты и композицию.

### 4.3 Запреты
- Не плодить “почти одинаковые” структуры для HLS/MP3, если различия можно выразить через generic/trait.
- Не делать “God traits” с десятками методов — лучше несколько маленьких.

---

## 6) Слабая связанность и модульность

**Цель:** компоненты должны быть независимыми блоками, которые можно собрать в систему.

### 6.1 Разделение ответственности
- Кэш — отдельный компонент.
- Сеть/загрузка — отдельный компонент.
- HLS orchestration — отдельный компонент.
- Декодирование — отдельный компонент.

### 6.2 Зависимости между крейтами
- Избегать циклических зависимостей.
- Зависимости направлены “вниз” к базовым абстракциям, но не обратно.
- Facade-слой (если есть) агрегирует компоненты, но не должен содержать “умной” логики.

### 6.3 Инкапсуляция
- Внешний код не должен знать про внутренние детали кэша (пути/файлы/lease-формат).
- Внешний код не должен зависеть от конкретного HTTP клиента, если это не часть контракта.

---

## 7) Линтинг/форматирование и единые настройки
**Цель:** единые правила форматирования и проверок во всём workspace.

- Агенты должны использовать и уважать workspace-конфиги:
  - `rustfmt.toml`
  - `clippy.toml`
  - `deny.toml`
- Если требуется изменить lint-политику:
  - предпочитать изменения в этих файлах (единая точка правды),
  - не настраивать "по месту" в отдельных крейтах без причины.
- Если необходимо унифицировать настройки через `workspace.metadata`, это делается в корневом `Cargo.toml`, а не в сабкрейтах.

### Code Style Rules (enforced by `scripts/lint-style.sh`)
- **No separator comments** (`// ====...`, `// ────...`) — используйте обычные `//` заголовки секций.
- **No inline qualified paths** — импортируйте всё в начале файла через `use`, не используйте `std::io::Error` в теле функций (пишите `io::Error`).
- **Struct fields ordered**: `pub` (alphabetical) → `pub(crate)` (alphabetical) → private (alphabetical). Исключения: serde/bincode типы с позиционной сериализацией.
- **`lib.rs`/`mod.rs`**: только `mod` объявления и `pub use` реэкспорты. Код и тесты — в отдельных файлах.

---

## 8) Общие правила качества (коротко)

- Никаких `unwrap()`/`expect()` в прод-коде без очень веской причины.
- Ошибки должны быть типизированы и содержать контекст (что делали, с каким ресурсом).
- Логи — минимальные и полезные; не логировать секреты (ключи/токены/байты ключей).
- **Логирование (нормативно):**
  - вместо `println!` / `print!` / `dbg!` использовать `tracing` (`trace!`, `debug!`, `info!`, `warn!`, `error!`) с уровнем по смыслу;
  - добавлять контекст через поля (например: `asset_id`, `url`, `resource`, `variant`, `segment_idx`, `bytes`, `attempt`, `timeout_ms`);
  - в прод-коде не оставлять “временные” принты (в тестах допускается точечно, но предпочтительнее тоже `tracing`).
- Любые изменения публичных API сопровождаются тестами, которые фиксируют контракт.

### Имена
- Выбирать как можно более простые и короткие имена для функций/методов/типов.
- Предпочитать стандартные, очевидные слова (`open`, `new`, `get`, `put`, `read`, `write`, `seek`, `stream`, `send`, `recv`), если они точно отражают смысл.
- Избегать “умных”/длинных имён, которые кодируют внутреннюю реализацию или историю рефакторингов.

---

## 9) Что делать, если правила конфликтуют

- Если требование продукта противоречит правилам — сначала обсуждается компромисс и обновляется `AGENTS.md`.
- Любой “вынужденный” обход правила должен быть объяснён в `README` соответствующего сабкрейта (кратко, по делу).
