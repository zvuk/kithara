# Kithara — правила кодирования для автономных агентов

Этот документ задаёт правила разработки в репозитории `kithara`. Любые изменения, сделанные автономным агентом, должны соответствовать этим правилам.

Порядок чтения перед началом работы:
1) `AGENTS.md`
2) `docs/constraints.md`
3) `docs/kanban.md`

## 0) Главные принципы

- Минимум магии и скрытых зависимостей.
- Предсказуемость, тестируемость, воспроизводимость.
- Компоненты должны быть слабо связаны и заменяемы.
- Код — источник истины. Длинные объяснения — в `README` соответствующего сабкрейта.

---

## 1) Управление зависимостями (workspace-first)

**Правило:** все зависимости добавляются сначала в workspace, затем подключаются в конкретном крейте.

### 1.1 Где объявлять версии
- Версии зависимостей объявляются в корневом `Cargo.toml` workspace в секции:
  - `[workspace.dependencies]`
- Это относится ко всем зависимостям:
  - обычным (`dependencies`)
  - dev (`dev-dependencies`)
  - build (`build-dependencies`)

### 1.2 Как подключать в крейтах
- В `Cargo.toml` конкретного крейта зависимости подключаются без версии:
  - `dep = { workspace = true }`
- Никаких версий в сабкрейтах. Если нужно изменить версию — меняем только в `[workspace.dependencies]`.

### 1.3 Запреты
- Не добавлять “временные” зависимости без реальной необходимости.
- Не тянуть тяжёлые зависимости ради мелкой утилиты (сначала оцени стоимость).
- Не дублировать одну и ту же зависимость с разными фичами в разных крейтах без явной причины.

---

## 2) Стиль кода (коротко и стабильно)

### 2.1 Имена
- Выбирать как можно более простые и короткие имена для функций/методов/типов.
- Предпочитать стандартные, очевидные слова (`open`, `new`, `get`, `put`, `read`, `write`, `seek`, `stream`, `send`, `recv`), если они точно отражают смысл.
- Избегать “умных”/длинных имён, которые кодируют внутреннюю реализацию или историю рефакторингов.

### 2.2 Комментарии и документация
**Цель:** минимизировать устаревающие комментарии и держать объяснения рядом с интерфейсами.

- Комментарии в коде — только короткие, однострочные.
- Не добавлять “простыни” комментариев в начале файлов.
- Не писать комментарии, которые повторяют код (очевидное).
- Всё, что требует объяснения (контракты, инварианты, жизненный цикл, протоколы, схемы кэша), описывается в:
  - `README.md` соответствующего сабкрейта (предпочтительно),
  - либо в `docs/` (если это кросс-сабкрейтовое).

### 2.3 Размер файлов и декомпозиция
**Цель:** Rust файлы должны оставаться небольшими, чтобы упрощать навигацию и снижать стоимость ревью.

- Не раздувать один `.rs` файл “до бесконечности”.
- Если файл начинает превращаться в “свалку абстракций”, выносить:
  - типы в отдельные файлы,
  - имплементации в `mod.rs` + `*.rs`,
  - политики/стратегии в отдельные модули.
- Эвристики (что выносить):
  - большие `enum`/`struct` + их `impl` блоки,
  - подсистемы (например: `lru_index`, `fs_layout`, `atomic_write`, `url_canon`, `key_processor`),
  - тестовые фикстуры/серверы — в отдельные модули под `tests/` или `src/fixtures.rs` (если это test-only под `cfg(test)`).

---

## 3) Разработка через TDD

**Правило:** изменения делаются через тесты, описывающие желаемое поведение.

### 4.1 Порядок работы
1) Сформулировать поведение через тест(ы) (integration/unit — по месту).
2) Запустить тесты и убедиться, что новый тест падает по ожидаемой причине.
3) Реализовать минимальный код, чтобы тест прошёл.
4) Рефакторить только после прохождения тестов.

### 4.2 Требования к тестам
- Тесты должны быть детерминированными.
- Тесты не должны зависеть от внешней сети.
- Тесты должны быть “умеренными” по объёму логов и данных (без чтения гигабайт и без шумных дампов).
- Тесты фиксируют контракт, а не текущие случайные детали реализации.

---

## 4) Обобщённое программирование (generics-first)

**Правило:** расширяемость достигается через дженерики и абстракции, а не через копипасту и жёсткие связи.

### 4.1 Предпочитать стандартные и tokio-абстракции
**Цель:** меньше “велосипедов”, больше совместимости с экосистемой.
- По возможности использовать стандартные и `tokio` трейты/типы и их идиомы:
  - конвертации (`From`, `TryFrom`, `Into`, `AsRef`),
  - ошибки (`std::error::Error`, `thiserror`),
  - итераторы и адаптеры (`Iterator`, `IntoIterator`),
  - I/O трейты (`Read`, `Seek`, `Write`, `AsyncRead`, `AsyncWrite` там, где уместно),
  - каналы/синхронизация `tokio` (если компонент уже на tokio) вместо кастомных решений.
- Если стандартный трейт подходит, не вводить новый “почти такой же” трейт.

### 4.2 Использование generics
- Базовые структуры делаем обобщёнными по:
  - типу события,
  - типу источника/транспорта,
  - типу кэша/хранилища,
  - политике (ABR/eviction) и т.п.
- Расширение поведения — через параметры типов, трейты и композицию.

### 4.3 Запреты
- Не плодить “почти одинаковые” структуры для HLS/MP3, если различия можно выразить через generic/trait.
- Не делать “God traits” с десятками методов — лучше несколько маленьких.

---

## 6) Слабая связанность и модульность

**Цель:** компоненты должны быть независимыми блоками, которые можно собрать в систему.

### 6.1 Разделение ответственности
- Кэш — отдельный компонент.
- Сеть/загрузка — отдельный компонент.
- HLS orchestration — отдельный компонент.
- Декодирование — отдельный компонент.

### 6.2 Зависимости между крейтами
- Избегать циклических зависимостей.
- Зависимости направлены “вниз” к базовым абстракциям, но не обратно.
- Facade-слой (если есть) агрегирует компоненты, но не должен содержать “умной” логики.

### 6.3 Инкапсуляция
- Внешний код не должен знать про внутренние детали кэша (пути/файлы/lease-формат).
- Внешний код не должен зависеть от конкретного HTTP клиента, если это не часть контракта.

---

## 7) Линтинг/форматирование и единые настройки
**Цель:** единые правила форматирования и проверок во всём workspace.

- Агенты должны использовать и уважать workspace-конфиги:
  - `rustfmt.toml`
  - `clippy.toml`
  - `deny.toml`
- Если требуется изменить lint-политику:
  - предпочитать изменения в этих файлах (единая точка правды),
  - не настраивать “по месту” в отдельных крейтах без причины.
- Если необходимо унифицировать настройки через `workspace.metadata`, это делается в корневом `Cargo.toml`, а не в сабкрейтах.

---

## 8) Общие правила качества (коротко)

- Никаких `unwrap()`/`expect()` в прод-коде без очень веской причины.
- Ошибки должны быть типизированы и содержать контекст (что делали, с каким ресурсом).
- Логи — минимальные и полезные; не логировать секреты (ключи/токены/байты ключей).
- Любые изменения публичных API сопровождаются тестами, которые фиксируют контракт.

### Имена
- Выбирать как можно более простые и короткие имена для функций/методов/типов.
- Предпочитать стандартные, очевидные слова (`open`, `new`, `get`, `put`, `read`, `write`, `seek`, `stream`, `send`, `recv`), если они точно отражают смысл.
- Избегать “умных”/длинных имён, которые кодируют внутреннюю реализацию или историю рефакторингов.

---

## 9) Что делать, если правила конфликтуют

- Если требование продукта противоречит правилам — сначала обсуждается компромисс и обновляется `AGENTS.md`.
- Любой “вынужденный” обход правила должен быть объяснён в `README` соответствующего сабкрейта (кратко, по делу).